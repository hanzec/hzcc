//
// Created by chen_ on 2022/4/10.
//

#include "JVMGenerator.h"

#include <glog/logging.h>

#include <filesystem>
#include <fstream>

#include "AST/CompilationUnit.h"
#include "const_code_block.h"
#include "utils/logging.h"
#include "version.h"
namespace Hzcc::Codegen {
Status JVMGenerator::Generate(const std::string& output,
                              AST::CompilationUnit& unit) {
    // output file name will be replaced by the input file with .class
    _intput_file_name = unit.GetFileName();
    std::filesystem::path input_path(unit.GetFileName());
    DVLOG(CODE_GEN_LEVEL) << "input file: " << unit.GetFileName()
                          << ", output file: " << output;

    // generate class file
    std::ofstream output_file(output);

    // write class file header
    output_file << ";; Generated by Hzcc" << FULL_VERSION << "\n"
                << ";; From Language: c\n"
                << ";; Source Path: " << unit.GetFileName() << "\n";

    // write class file body
    _current_class_name = input_path.replace_extension().filename();
    output_file << ".class public " << _current_class_name << "\n"
                << ".super java/lang/Object\n";

    /** #####################################################################
     *  ### Global Variables                                              ###
     *  ##################################################################### */
    IncLindeIndent();
    for (auto& ast_node : unit.GetDecls()) {
        if (!ast_node.second->IsFuncDecl()) {
            auto type_name = Utils::GetTypeName(ast_node.second->GetType());

            // push to cinit section
            _global_vars.emplace(ast_node.first, type_name);

            // generate global variable
            std::transform(type_name.begin(), type_name.end(),
                           type_name.begin(), ::toupper);
            AddToCache(".field public static " + ast_node.first + " " +
                       type_name);

            // Only generate global variables' initialization needed
            if (ast_node.second->GetType()->IsArray() ||
                ast_node.second->HasInitExpr()) {
                AddToCache(".method static <clinit> : ()V");
                IncLindeIndent();
                AddToCache(".code stack 2 locals 0");
                IncLindeIndent();
                HZCC_JVM_NOT_REQUEST_LEAVE_VAL(                // NOLINT
                    HZCC_JVM_NOT_GENERATE_LOAD_INSTR(          // NOLINT
                        HZCC_ExceptOK_WITH_RETURN(             // NOLINT
                            ast_node.second->visit(*this))));  // NOLINT
                AddToCache("return");
                DecLindeIndent();
                AddToCache(".end code");
                DecLindeIndent();
                AddToCache(".end method\n");
            }
        }
    }
    DecLindeIndent();

    /** #####################################################################
     *  ### Functions                                                      ###
     *  ##################################################################### */
    IncLindeIndent();
    for (auto& ast_node : unit.GetDecls()) {
        if (ast_node.second->IsFuncDecl()) {
            auto* func_ptr =
                dynamic_cast<AST::FunctionDeclNode*>(ast_node.second.get());
            if (func_ptr->HasBody()) {
                auto [func_ret, func_args, _] =
                    unit.getFuncRetAndArgType(func_ptr->GetName());

                // generate function header
                std::stringstream func_signature;
                func_signature << '(';
                for (auto& arg : func_args)
                    func_signature << Utils::GetTypeName(arg);
                func_signature << ')' << Utils::GetTypeName(func_ret);

                // add to function table
                auto final_func_signature = func_signature.str();
                std::transform(final_func_signature.begin(),
                               final_func_signature.end(),
                               final_func_signature.begin(), ::toupper);
                _function_table[func_ptr->GetName()] = {GetCurrentClassName(),
                                                        final_func_signature};
            }

            // visit function
            HZCC_ExceptOK_WITH_RETURN(func_ptr->visit(*this));
            AddToCache("");  // add empty line
        }
    }
    output_file << GetAllCachedLine();
    DecLindeIndent();

    // write class file tail
    output_file << R"(
; Special methods

.method <init> : ()V
    .code stack 1 locals 1
        aload_0
        invokespecial Method java/lang/Object <init> ()V
        return
    .end code
.end method

.method public static main : ([Ljava/lang/String;)V
    .code stack 2 locals 2
        invokestatic Method )"
                << GetCurrentClassName() << R"( main ()I
        istore_1
        getstatic Field java/lang/System out Ljava/io/PrintStream;
        ldc 'Return code: '
        invokevirtual Method java/io/PrintStream print (Ljava/lang/String;)V
        getstatic Field java/lang/System out Ljava/io/PrintStream;
        iload_1
        invokevirtual Method java/io/PrintStream println (I)V
        return
    .end code
.end method
)";
    output_file.close();

    return Status::OkStatus();
}

std::string JVMGenerator::GetVarType(const std::string& name) {
    if (_local_vars.find(name) != _local_vars.end()) {
        return _local_vars[name].second;
    } else if (_global_vars.find(name) != _global_vars.end()) {
        return _global_vars[name];
    } else {
        LOG(FATAL) << "Variable " << name << " not found";
    }
}

std::string JVMGenerator::SaveToVariable(const std::string& name) {
    if (_local_vars.find(name) != _local_vars.end()) {
        auto [stack_id, var_type] = _local_vars[name];
        if (var_type.find('[') != std::string::npos) {
            var_type.erase(var_type.find('['), 1);
            return var_type + "astore";
        } else {
            // convert char to int if necessary
            if (var_type == "c") {
                var_type = "i";
            }
            return var_type + "store " + std::to_string(stack_id);
        }
    } else if (_global_vars.find(name) != _global_vars.end()) {
        auto var_type = _global_vars[name];
        if (var_type.find('[') != std::string::npos) {
            var_type.erase(var_type.find('['), 1);
            return var_type + "astore";
        } else {
            // to upper case
            std::transform(var_type.begin(), var_type.end(), var_type.begin(),
                           ::toupper);
            return "putstatic Field " + GetCurrentClassName() + " " + name +
                   " " + var_type;
        }
    } else {
        LOG(FATAL) << "Variable " << name << " not found";
    }
}

std::string JVMGenerator::LoadFromVariable(const std::string& name) {
    if (_local_vars.find(name) != _local_vars.end()) {
        auto [stack_id, var_type] = _local_vars[name];
        if (var_type.find('[') != std::string::npos) {
            var_type.erase(var_type.find('['), 1);
            return var_type + "aload " + std::to_string(stack_id);
        } else {
            // convert char to int if necessary
            if (var_type == "c") {
                var_type = "i";
            }
            return var_type + "load " + std::to_string(stack_id);
        }
    } else if (_global_vars.find(name) != _global_vars.end()) {
        auto var_type = _global_vars[name];
        std::transform(var_type.begin(), var_type.end(), var_type.begin(),
                       ::toupper);
        return "getstatic Field " + GetCurrentClassName() + " " + name + " " +
               var_type;
    } else {
        LOG(FATAL) << "Variable " << name << " not found";
    }
}

void JVMGenerator::IncLindeIndent() { _indent += _indent_str; }

void JVMGenerator::DecLindeIndent() {
    _indent = _indent.substr(0, _indent.size() - 4);
}

uint32_t JVMGenerator::GetStackID(std::string& name) {
    if (_local_vars.find(name) != _local_vars.end()) {
        return _local_vars[name].first;
    } else {
        LOG(FATAL) << "Variable " << name << " not found";
    }
}

bool JVMGenerator::IsGlobalVar(const std::string& name) {
    return _global_vars.find(name) != _global_vars.end();
}

void JVMGenerator::PushReturnStack(const std::string& stackID) {
    _return_stack.push_back(stackID);
}

std::string JVMGenerator::ConsumeReturnStack() {
    auto poped_stack = _return_stack.back();
    _return_stack.pop_back();
    return poped_stack;
}

void JVMGenerator::AddToCache(const std::string& output) {
    _output << _indent << output << std::endl;
}

const std::string& JVMGenerator::GetInputFileName() {
    DLOG_ASSERT(!_intput_file_name.empty())
        << "Call GetInputFileName without setting up the input file name!";
    return _intput_file_name;
}

const std::string& JVMGenerator::GetCurrentClassName() {
    DLOG_ASSERT(!_current_class_name.empty())
        << "Call GetInputFileName without setting up the input file name!";
    return _current_class_name;
}

std::string JVMGenerator::GetAllCachedLine() { return _output.str(); }

bool JVMGenerator::IsLocalVar(const std::string& name) {
    return _local_vars.find(name) != _local_vars.end();
}

}  // namespace Hzcc::Codegen
