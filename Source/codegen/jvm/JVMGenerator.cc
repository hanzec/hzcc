//
// Created by chen_ on 2022/4/10.
//

#include "JVMGenerator.h"

#include <glog/logging.h>

#include <filesystem>
#include <fstream>

#include "AST/CompilationUnit.h"
#include "const_code_block.h"
#include "utils/logging.h"
#include "version.h"
namespace Hzcc::Codegen {
JVMGenerator::JVMGenerator(const std::string& output,
                           AST::CompilationUnit& unit)
    : Generator(output, unit),
      StackManager(std::filesystem::path(unit.GetFileName())
                       .replace_extension()
                       .filename()) {
    _input_file_name = unit.GetFileName();
    _current_class_name =
        std::filesystem::path(_input_file_name).replace_extension().filename();
}

Status JVMGenerator::Generate() {
    auto& unit = GetCompilationUnit();
    // output file name will be replaced by the input file with .class
    auto _output_file = unit.GetFileName();
    DVLOG(CODE_GEN_LEVEL) << "input file: " << unit.GetFileName()
                          << ", output file: " << GetOutputFilePath();

    // generate class file
    std::ofstream output_file(GetOutputFilePath());

    // write class file header
    output_file << ";; Generated by Hzcc" << FULL_VERSION << "\n"
                << ";; From Language: c\n"
                << ";; Source Path: " << unit.GetFileName() << "\n";

    // write class file body
    output_file << ".class public " << _current_class_name << "\n"
                << ".super java/lang/Object\n";

    /** #####################################################################
     *  ### Global Variables                                              ###
     *  ##################################################################### */
    IncLindeIndent();
    for (auto& ast_node : unit.GetDecls()) {
        if (!ast_node.second->IsFuncDecl()) {
            auto type_name = Utils::GetTypeName(ast_node.second->GetType());

            // push to cinit section
            AddGlobalVar(ast_node.first, type_name);

            // generate global variable
            std::transform(type_name.begin(), type_name.end(),
                           type_name.begin(), ::toupper);
            AddToCache(".field public static " + ast_node.first + " " +
                       type_name);

            // Only generate global variables' initialization needed
            if (ast_node.second->GetType()->IsArray() ||
                ast_node.second->HasInitExpr()) {
                AddToCache(".method static <clinit> : ()V");
                IncLindeIndent();
                AddToCache(".code stack 2 locals 0");
                IncLindeIndent();
                HZCC_JVM_NOT_REQUEST_LEAVE_VAL(                // NOLINT
                    HZCC_JVM_NOT_GENERATE_LOAD_INSTR(          // NOLINT
                        HZCC_ExceptOK_WITH_RETURN(             // NOLINT
                            ast_node.second->visit(*this))));  // NOLINT
                AddToCache("return");
                DecLindeIndent();
                AddToCache(".end code");
                DecLindeIndent();
                AddToCache(".end method\n");
            }
        }
    }
    DecLindeIndent();

    /** #####################################################################
     *  ### Functions                                                      ###
     *  ##################################################################### */
    IncLindeIndent();
    for (auto& ast_node : unit.GetDecls()) {
        if (ast_node.second->IsFuncDecl()) {
            auto* func_ptr =
                dynamic_cast<AST::FunctionDeclNode*>(ast_node.second.get());
            if (func_ptr->HasBody()) {
                auto [func_ret, func_args, _] =
                    unit.getFuncRetAndArgType(func_ptr->GetName());

                // generate function header
                std::stringstream func_signature;
                func_signature << '(';
                for (auto& arg : func_args)
                    func_signature << Utils::GetTypeName(arg);
                func_signature << ')' << Utils::GetTypeName(func_ret);

                // add to function table
                auto final_func_signature = func_signature.str();
                std::transform(final_func_signature.begin(),
                               final_func_signature.end(),
                               final_func_signature.begin(), ::toupper);
                _function_table[func_ptr->GetName()] = {GetCurrentClassName(),
                                                        final_func_signature};
            }

            // visit function
            HZCC_ExceptOK_WITH_RETURN(func_ptr->visit(*this));
            AddToCache("");  // add empty line
        }
    }
    output_file << GetAllCachedLine();
    DecLindeIndent();

    // write class file tail
    output_file << R"(
; Special methods

.method <init> : ()V
    .code stack 1 locals 1
        aload_0
        invokespecial Method java/lang/Object <init> ()V
        return
    .end code
.end method

.method public static main : ([Ljava/lang/String;)V
    .code stack 2 locals 2
        invokestatic Method )"
                << GetCurrentClassName() << R"( main ()I
        istore_1
        getstatic Field java/lang/System out Ljava/io/PrintStream;
        ldc 'Return code: '
        invokevirtual Method java/io/PrintStream print (Ljava/lang/String;)V
        getstatic Field java/lang/System out Ljava/io/PrintStream;
        iload_1
        invokevirtual Method java/io/PrintStream println (I)V
        return
    .end code
.end method
)";
    output_file.close();

    return Status::OkStatus();
}

std::string JVMGenerator::ConsumeReturnStack() {
    auto poped_stack = _return_stack.back();
    _return_stack.pop_back();
    return poped_stack;
}

const std::string& JVMGenerator::GetCurrentClassName() {
    DLOG_ASSERT(!_current_class_name.empty())
        << "Call GetInputFileName without setting up the input file name!";
    return _current_class_name;
}

void JVMGenerator::PushReturnStack(const std::string& stackID) {
    _return_stack.push_back(stackID);
}
}  // namespace Hzcc::Codegen::JVM
